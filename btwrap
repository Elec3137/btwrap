#!/bin/sh
r="\033[31;1m"
c="\033[36;1m"
e="\033[0m"
dict_path="/usr/share/dict/cracklib-small"


print_usage() {
printf "${c}Shell wrapper for btrfs snapshots (creation, cleanup, space usage polling)${e}

${c}Global options${e}
    -q            ${c}quiet${e} (suppress extra warnings and all confirmations)

${c}Actions${e}
    -C <dir>      ${c}create${e} a subvolume '.snapshots' under specified subvolume
    -S            ${c}snapshot${e} every subvolume that contains a '.snapshots' subvolume
    -D            ${r}delete${e} the oldest snapshot from each '.snapshots' subvolume
    -L            ${c}list${e} all snapshots
    -U            poll for disk ${c}usage${e} summary of each '.snapshots' subvolume
    -G            update ${c}grub${e} (for grub-btrfs)
    -E <dir>      ${c}exclude${e} from any parent snapshots by converting target into a subvolume
${c}Options${e}
    -m <path>     specify the subvolume instead of searching (for actions D,S,d)

${c}Example usage:${e}
btwrap -C /home     # creates subvolume /home/.snapshots
btwrap -Sm /home    # snapshots /home subvolume into /home/.snapshots/<name>
btwrap -SD          # for each '.snapshots' subvolume: delete the oldest snapshot within and then snapshot the parent subvolume into it
"
}

sfd() {    # finds only toplevel directories with the name ".snapshots"

#sudo find / -name .snapshots -prune -name ".snapshots" 2>/dev/null
#fd -H "\.snapshots" / | grep -vE "/.snapshots/.*.snapshots/"

sudo btrfs subv list / | grep snapshots$ | cut -d " " -f 9 | cut -d '@' -f 2
}

subvCreate() {    # create
    subvConvert "$1"
    sudo btrfs subv create "$1/.snapshots"
}

snapTake() {    # snapshot
    rand=$(dd if=/dev/urandom count=1 2> /dev/null | cksum | cut -d' ' -f1)

    if [ -r $dict_path ]; then  # if $dict_path DOES exist and is readable
        name=$(shuf -n 1 $dict_path)$rand
    else
        [ ! "$quiet" = "true" ] && printf "${c}Unreadable or DNE: ${dict_path} falling back to just random int${e}\n"
        name=$rand
    fi


    if [ -z "$path" ]; then   # if $path is empty
        for i in $(sfd); do
            sudo btrfs subv snap -r "/$i/../" "/$i/$name"
        done
    else
        sudo btrfs subv snap -r "$path" "$path/.snapshots/$name"
    fi
}

snapDelete() {    # delete
    # setting of (deletion) $target needs a weird "echo" (to output it all at once to awk?)
    # and echoed command MUST NOT be in double quotes (why?)

    if [ -z "$path" ]; then    # $path is empty
        for i in $(sfd); do
            target=$(echo $(sudo ls -t --time creation "/$i") | awk '{print $NF}')

            if [ -n "$target" ]; then
                if [ ! "$quiet" = "true" ] && [ ! "$all" = "true" ]; then
                    printf "Delete '/${i}/$target'? [Y/n/all] "
                    read -r response
                    case "$response" in
                        y|Y|yes|Yes|'' );;
                        n|N|no|No ) return;;
                        all ) all=true;;
                        * ) return;;
                    esac
                fi
                sudo btrfs subv delete "/${i}/$target"
            else
                [ ! "$quiet" = "true" ] && printf "${c}no snapshots to delete in '${e}/$i${c}', skipping deletion of:${e} /${i}/$target\n"
            fi
        done
    else
        target=$(echo $(sudo ls -t --time creation "$path/.snapshots") | awk '{print $NF}')

        if [ -n "$target" ]; then
            if [ ! "$quiet" = "true" ] && [ ! "$all" = "true" ]; then
                printf "Delete '${path}/.snapshots/$target'? [Y/n] "
                read -r response
                case "$response" in
                    y|Y|yes|Yes|'' );;
                    n|N|no|No ) return;;
                    * ) return;;
                esac
            fi

            sudo btrfs subv delete "${path}/.snapshots/$target"
        else
            [ ! "$quiet" = "true" ] && printf "${c}no snapshots to delete in '${e}$path/.snapshots/${c}', skipping deletion of:${e} ${path}/.snapshots/$target\n"
        fi
    fi
}

snapList() {    # list
    if [ -z "$path" ]; then   # if $path is empty
        sudo btrfs subv list -st /
    else
        sudo btrfs subv list -sto "$path"
    fi
}

diskUsage() {    # usage
    [ ! "$quiet" = "true" ] && printf "${c}be patient please! this may take a while:${e}\n"
    if [ -z "$path" ]; then
        for i in $(sfd); do
            sudo btrfs filesystem du -s "/$i"
        done
    else
        sudo btrfs filesystem du -s "$path/.snapshots"
    fi
}

subvConvert() {    # exclude
    if [ -n "$1" ]; then
        convTarget=$1

        # if $convTarget is NOT a btrfs subvolume but is still on a btrfs filesystem
        if [ ! "$(stat --format=%i "$convTarget")" -eq 256 ] && [ "$(stat -f --format=%T "$convTarget")" = "btrfs" ] ; then
            sudo mv "$convTarget" "$convTarget.old" || exit # tries to move $convTarget to a subdirectory of itself if it ends in a "/"
            sudo btrfs subv create "$convTarget" || exit
            sudo chown "$USER" "$convTarget" || exit
            sudo mv "$convTarget".old/* "$convTarget/" || exit
            sudo rm -rf "$convTarget.old"
        else
            [ ! "$quiet" = "true" ] && printf "${c}directory -> subvolume conversion target is invalid${e}"
            exit
        fi

    fi
}

optstring="m:LUC:Sn:DqGE:"
while getopts $optstring option; do
    case "$option" in
        m) path=${OPTARG};;
        q) quiet=true;;
    esac
done

OPTIND=1

while getopts $optstring option; do
    case "$option" in
            m) path=${OPTARG};;
            q) quiet=true;;

        C) subvCreate "${OPTARG}";;
        S) snapTake;;
        D) snapDelete;;
        L) snapList;;
        U) diskUsage;;
        E) subvConvert "${OPTARG}";;

        G) sudo grub-mkconfig -o /boot/grub/grub.cfg;;

        *) printf "\n"
            print_usage
            exit 1 ;;
    esac
done

